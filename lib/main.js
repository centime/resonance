// Generated by CoffeeScript 1.6.2
(function() {
  var Channel, Tests, URL, activePrivateUsers, chan, client, closePage, currentPmUser, data, date, emitToAllWorkers, getChan, irc, list, m, mutedUsers, openPage, panel, passEvent, pmUsers, setTimeout, sha1, startClient, storage, tabs, testBot, testChan, testPortReplies, tests, user, workers, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  data = require("sdk/self").data;

  URL = require('sdk/url').URL;

  tabs = require('sdk/tabs');

  data = require("sdk/self").data;

  storage = require("sdk/simple-storage").storage;

  sha1 = require('./sha1.js').sha1;

  irc = require('./_irc.js');

  if ((_ref = storage.resonanceOptions) == null) {
    storage.resonanceOptions = {
      'activated': true,
      'startByDefault': false,
      'startForDomains': [],
      'nick': 'zob_du_test'
    };
  }

  if ((_ref1 = storage.messagesHistory) == null) {
    storage.messagesHistory = {};
  }

  if ((_ref2 = storage.privateMessagesHistory) == null) {
    storage.privateMessagesHistory = {};
  }

  activePrivateUsers = {};

  mutedUsers = (_ref3 = storage.mutedUsers) != null ? _ref3 : [];

  workers = {};

  pmUsers = ['Resonance-bot'];

  currentPmUser = 'Resonance-bot';

  client = {};

  _ref4 = storage.messagesHistory;
  for (chan in _ref4) {
    list = _ref4[chan];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      m = list[_i];
      m.old = 'true';
    }
  }

  _ref5 = storage.privateMessagesHistory;
  for (user in _ref5) {
    list = _ref5[user];
    for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
      m = list[_j];
      m.old = 'true';
    }
  }

  startClient = function(opt) {
    client = new irc.Client('chat.freenode.net', opt.nick, {
      debug: true
    });
    client.addListener('error', function(message) {
      emitToAllWorkers('error', message.command + message.args.join(' '));
      return console.error('ERROR:', message.command, message.args.join(' '));
    });
    client.addListener('registered', function(message) {
      return client.connected = true;
    });
    passEvent('names');
    passEvent('join');
    client.addListener('message', function(from, to, message) {
      var _base, _ref6;

      if (to !== opt.nick) {
        workers[to].emit('message', from, to, message);
        if ((_ref6 = (_base = storage.messagesHistory)[to]) == null) {
          _base[to] = [];
        }
        return storage.messagesHistory[to].push({
          'author': from,
          'message': message
        });
      }
    });
    client.addListener('pm', function(from, message) {
      var _base, _ref6;

      if (from === 'Resonance-bot' && message.match(/^announce /)) {
        message = message.replace('announce ', '');
        return emitToAllWorkers('announce', message);
      } else if (from === 'Resonance-bot' && message.match(/^topPages /)) {
        message = message.replace('topPages ', '');
        return emitToAllWorkers('topPages', message);
      } else {
        if (!(__indexOf.call(pmUsers, from) >= 0)) {
          pmUsers.push(from);
          emitToAllWorkers('pmUsers', pmUsers);
        }
        if ((_ref6 = (_base = storage.privateMessagesHistory)[from]) == null) {
          _base[from] = [];
        }
        storage.privateMessagesHistory[from].push({
          'author': from,
          'message': message
        });
        activePrivateUsers[from] = true;
        emitToAllWorkers('activePrivateUsers', activePrivateUsers);
        if (from === currentPmUser) {
          return emitToAllWorkers('privateMessage', from, opt.nick, message);
        }
      }
    });
    client.addListener('part', function(chan, nick) {
      if (nick !== opt.nick) {
        return workers[chan].emit('part', chan, nick);
      }
    });
    return client;
  };

  getChan = function(url, title) {
    var domain, _ref6, _ref7;

    domain = (_ref6 = url.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)) != null ? (_ref7 = _ref6[2]) != null ? _ref7 : _ref6[2] = '' : void 0;
    return '#' + sha1(domain + title).toString();
  };

  passEvent = function(eventName) {
    return client.addListener(eventName, function(chan, a, b, c, d, e, f, g, h, i) {
      if (workers[chan] != null) {
        return workers[chan].emit(eventName, chan, a, b, c, d, e, f, g, h, i);
      }
    });
  };

  emitToAllWorkers = function(eventName, a, b, c, d, e, f, g, h, i) {
    var worker, _results;

    _results = [];
    for (chan in workers) {
      if (!__hasProp.call(workers, chan)) continue;
      worker = workers[chan];
      _results.push(worker.emit(eventName, a, b, c, d, e, f, g, h, i));
    }
    return _results;
  };

  Channel = (function() {
    function Channel(chan, worker) {
      this.chan = chan;
      this.linkedWorkers = [worker];
    }

    Channel.prototype.addWorker = function(worker) {
      return this.linkedWorkers.push(worker);
    };

    Channel.prototype.removeWorker = function(worker) {
      var w;

      return this.linkedWorkers = (function() {
        var _k, _len2, _ref6, _results;

        _ref6 = this.linkedWorkers;
        _results = [];
        for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
          w = _ref6[_k];
          if (w !== worker) {
            _results.push(w);
          }
        }
        return _results;
      }).call(this);
    };

    Channel.prototype.emit = function(eventName, a, b, c, d, e, f, g, h, i) {
      var w, _k, _len2, _ref6, _results;

      _ref6 = this.linkedWorkers;
      _results = [];
      for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
        w = _ref6[_k];
        _results.push(w.port.emit(eventName, a, b, c, d, e, f, g, h, i));
      }
      return _results;
    };

    Channel.prototype.hasWorkers = function() {
      return this.linkedWorkers.length > 0;
    };

    Channel.prototype.numWorkers = function() {
      return this.linkedWorkers.length;
    };

    return Channel;

  })();

  closePage = function(tab) {
    var previousChan, previousWorker;

    previousChan = tab.chan;
    previousWorker = tab.worker;
    workers[previousChan].removeWorker(previousWorker);
    if (!workers[previousChan].hasWorkers()) {
      client.part(previousChan);
      delete workers[previousChan];
    }
    tab.chan = void 0;
    return tab.worker = void 0;
  };

  openPage = function(tab) {
    var worker, _base, _ref6, _ref7, _ref8;

    chan = getChan(tab.url, tab.title);
    tab.chan = chan;
    client.join(chan);
    client.send('NAMES', chan);
    client.say('Resonance-bot', 'enter ' + tab.url + ' ' + chan);
    worker = tab.attach({
      contentScriptFile: [data.url("lib/jquery.js"), data.url("lib/angular.min.js"), data.url("content-built.js"), data.url("controllers/app.js"), data.url("controllers/ResonanceController.js"), data.url("controllers/IrcController.js"), data.url("controllers/MessagesController.js"), data.url("controllers/UsersController.js"), data.url("controllers/TopPagesController.js"), data.url("controllers/PrivateMessagesController.js"), data.url("controllers/PrivateUsersController.js"), data.url("tests.js")]
    });
    tab.worker = worker;
    if (workers[chan] != null) {
      workers[chan].addWorker(worker);
    } else {
      workers[chan] = new Channel(chan, worker);
    }
    worker.port.emit('appSize', (_ref6 = storage.appSize) != null ? _ref6 : '100');
    worker.port.emit('chan', chan);
    worker.port.emit('requestMutedUsers', mutedUsers);
    worker.port.emit('nick', storage.resonanceOptions.nick);
    worker.port.emit('messagesHistory', (_ref7 = storage.messagesHistory[chan]) != null ? _ref7 : []);
    worker.port.emit('pmUsers', pmUsers);
    if ((_ref8 = (_base = storage.privateMessagesHistory)[currentPmUser]) == null) {
      _base[currentPmUser] = [];
    }
    worker.port.emit('pmUser', currentPmUser, storage.privateMessagesHistory[currentPmUser]);
    worker.port.on('say', function(to, message) {
      var _base1, _ref9;

      client.say(to, message);
      workers[to].emit('message', storage.resonanceOptions.nick, to, message);
      if ((_ref9 = (_base1 = storage.messagesHistory)[to]) == null) {
        _base1[to] = [];
      }
      return storage.messagesHistory[to].push({
        'author': storage.resonanceOptions.nick,
        'message': message
      });
    });
    worker.port.on('privateMessage', function(user, message) {
      var _base1, _ref9;

      client.say(user, message);
      if ((_ref9 = (_base1 = storage.privateMessagesHistory)[user]) == null) {
        _base1[user] = [];
      }
      storage.privateMessagesHistory[user].push({
        'author': storage.resonanceOptions.nick,
        'message': message
      });
      return emitToAllWorkers('privateMessage', storage.resonanceOptions.nick, user, message);
    });
    worker.port.on('getTopPages', function(domain) {
      if (domain !== null && domain !== '') {
        return client.say('Resonance-bot', 'ask keyword ' + domain);
      } else {
        return client.say('Resonance-bot', 'ask global');
      }
    });
    worker.port.on('startPmUser', function(user) {
      var _base1, _ref9;

      currentPmUser = user;
      if (!(__indexOf.call(pmUsers, user) >= 0)) {
        pmUsers.push(user);
        emitToAllWorkers('pmUsers', pmUsers);
      }
      if ((_ref9 = (_base1 = storage.privateMessagesHistory)[user]) == null) {
        _base1[user] = [];
      }
      return emitToAllWorkers('pmUser', currentPmUser, storage.privateMessagesHistory[user]);
    });
    worker.port.on("updateMutedUsers", function(mutedUsers) {
      return storage.mutedUsers = mutedUsers;
    });
    worker.port.on('unactivePmUser', function(user) {
      activePrivateUsers[user] = false;
      return emitToAllWorkers('activePrivateUsers', activePrivateUsers);
    });
    worker.port.on("newAppSize", function(height) {
      storage.appSize = height;
      return emitToAllWorkers('appSize', height);
    });
    return worker.port.on('test', function(response) {
      return testPortReplies[response] = true;
    });
  };

  panel = require("sdk/panel").Panel({
    'width': 800,
    'height': 200,
    'contentURL': data.url("panel.html"),
    'contentScriptFile': [data.url("lib/angular.min.js"), data.url("lib/jquery.js"), data.url("panel_controllers/panel.js")]
  });

  require("sdk/widget").Widget({
    'id': "widget-open-settings",
    'label': "Resonance",
    'contentURL': data.url("History.png"),
    'panel': panel,
    'onClick': function() {
      var _base, _ref6, _ref7, _ref8;

      storage.resonanceOptions['domain'] = (_ref6 = tabs.activeTab.url.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)) != null ? (_ref7 = _ref6[2]) != null ? _ref7 : _ref6[2] = '' : void 0;
      storage.resonanceOptions['started'] = (_ref8 = (_base = tabs.activeTab).started) != null ? _ref8 : _base.started = 'false';
      return panel.port.emit('initOptions', storage.resonanceOptions);
    }
  });

  panel.port.on('updateOptions', function(opt) {
    return storage.resonanceOptions = opt;
  });

  panel.port.on('activate', function(value) {
    if (value) {
      return startClient(storage.resonanceOptions);
    } else {
      emitToAllWorkers('close');
      return client.disconnect();
    }
  });

  panel.port.on('startForPage', function(value) {
    if (value) {
      if (!tabs.activeTab.started) {
        openPage(tabs.activeTab);
        return tabs.activeTab.started = true;
      }
    } else {
      tabs.activeTab.worker.port.emit('close');
      closePage(tabs.activeTab);
      return tabs.activeTab.started = false;
    }
  });

  if (storage.resonanceOptions.activated) {
    startClient(storage.resonanceOptions);
  }

  tabs.on('ready', function(tab) {
    var domain, _ref6, _ref7;

    if (tab.chan != null) {
      closePage(tab);
    }
    if (storage.resonanceOptions.activated) {
      domain = (_ref6 = tab.url.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)) != null ? (_ref7 = _ref6[2]) != null ? _ref7 : _ref6[2] = '' : void 0;
      if (storage.resonanceOptions.startByDefault || (__indexOf.call(storage.resonanceOptions.startForDomains, domain) >= 0)) {
        openPage(tab);
        return tab.started = true;
      } else {
        return tab.started = false;
      }
    } else {
      return tab.started = false;
    }
  });

  tabs.on('close', function(tab) {
    workers[tab.chan].removeWorker(tab.worker);
    if (!workers[tab.chan].hasWorkers()) {
      client.part(tab.chan);
      return delete workers[tab.chan];
    }
  });

  if (false) {
    setTimeout = require('sdk/timers').setTimeout;
    Tests = (function() {
      function Tests() {
        this.assert = __bind(this.assert, this);        this.tests = [];
        this.rootTests = [];
      }

      Tests.prototype.add = function(test) {
        var prevTest, t, _ref6;

        test.followers = [];
        this.tests.push(test);
        if (!(_ref6 = test.previous, __indexOf.call((function() {
          var _k, _len2, _ref7, _results;

          _ref7 = this.tests;
          _results = [];
          for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
            t = _ref7[_k];
            _results.push(t.name);
          }
          return _results;
        }).call(this), _ref6) >= 0)) {
          return this.rootTests.push(test);
        } else {
          prevTest = ((function() {
            var _k, _len2, _ref7, _results;

            _ref7 = this.tests;
            _results = [];
            for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
              t = _ref7[_k];
              if (t.name === test.previous) {
                _results.push(t);
              }
            }
            return _results;
          }).call(this))[0];
          return this.follow(test, prevTest);
        }
      };

      Tests.prototype.follow = function(follower, firstTest) {
        return firstTest.followers.push(follower);
      };

      Tests.prototype.run = function() {
        var test, _k, _len2, _ref6, _results;

        _ref6 = this.rootTests;
        _results = [];
        for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
          test = _ref6[_k];
          _results.push(this.assert(test));
        }
        return _results;
      };

      Tests.prototype.assert = function(test) {
        var assert, next, result, _k, _len2, _ref6, _results;

        result = '\n\t\tFAILED.\n';
        if (test.check()) {
          result = 'Passed.';
        }
        if (!(test.prereq != null)) {
          console.log('[[ TESTS ]] ' + test.name + ' : ' + result);
        }
        assert = this.assert;
        _ref6 = test.followers;
        _results = [];
        for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
          next = _ref6[_k];
          _results.push((function(next) {
            return setTimeout((function() {
              return assert(next);
            }), next.delay);
          })(next));
        }
        return _results;
      };

      return Tests;

    })();
    tests = new Tests();
    tests.add({
      'name': 'Addon started',
      'previous': '',
      'delay': 0,
      'check': function() {
        return true;
      }
    });
    tests.add({
      'name': 'Storage available',
      'previous': '',
      'delay': 0,
      'check': function() {
        return storage != null;
      }
    });
    tests.add({
      'name': 'Client connected in less than 20s',
      'previous': 'Addon started',
      'delay': 20000,
      'check': function() {
        return client.connected;
      }
    });
    testPortReplies = {};
    tests.add({
      'prereq': true,
      'name': 'Open sebsauvage.net',
      'previous': 'Addon started',
      'delay': 1000,
      'check': function() {
        return tabs.open('sebsauvage.net');
      }
    });
    tests.add({
      'prereq': true,
      'name': 'sebsauvage.net is open',
      'previous': 'Open sebsauvage.net',
      'delay': 10000,
      'check': function() {
        return tabs.activeTab.url === 'http://sebsauvage.net/';
      }
    });
    testChan = '';
    tests.add({
      'name': 'tab.chan is correctly defined for sebsauvage',
      'previous': 'sebsauvage.net is open',
      'delay': 100,
      'check': function() {
        testChan = getChan(tabs.activeTab.url, tabs.activeTab.title);
        return tabs.activeTab.chan === testChan;
      }
    });
    tests.add({
      'prereq': true,
      'name': 'Test port communication with the tab of sebsauvage',
      'previous': 'sebsauvage.net is open',
      'delay': 100,
      'check': function() {
        return workers[testChan].emit('test', 'Test port communication');
      }
    });
    tests.add({
      'name': 'workers[chan] allow communication with the correct tab for sebsauvage ',
      'previous': 'Test port communication with the tab of sebsauvage',
      'delay': 300,
      'check': function() {
        return testPortReplies['Test port communication : sebsauvage.net'];
      }
    });
    tests.add({
      'prereq': true,
      'name': 'App displayed, ~full ?',
      'previous': 'sebsauvage.net is open',
      'delay': 2000,
      'check': function() {
        return workers[testChan].emit('test', 'App displayed, ~full ?');
      }
    });
    tests.add({
      'name': 'The app is displayed (>90% width)',
      'previous': 'App displayed, ~full ?',
      'delay': 1000,
      'check': function() {
        return testPortReplies['App displayed, ~full ? : true'];
      }
    });
    testBot = 'Resonance-test';
    storage.messagesHistory = {};
    storage.privateMessagesHistory = {};
    tests.add({
      'name': 'Connected to the corresponding chan',
      'previous': 'Client connected in less than 20s',
      'delay': 4000,
      'check': function() {
        client.say(testBot, 'join ' + testChan);
        for (chan in client.chans) {
          if (chan === testChan) {
            return true;
          }
        }
        return false;
      }
    });
    date = new Date();
    date = date.toString();
    tests.add({
      'prereq': true,
      'name': 'Send a message in the chan via the testing bot',
      'previous': 'Connected to the corresponding chan',
      'delay': 2000,
      'check': function() {
        return client.say(testBot, 'say ' + testChan + ' ' + date);
      }
    });
    tests.add({
      'name': 'Receive a message and save it in history',
      'previous': 'Send a message in the chan via the testing bot',
      'delay': 4000,
      'check': function() {
        var e;

        return __indexOf.call((function() {
          var _k, _len2, _ref6, _results;

          _ref6 = storage.messagesHistory[testChan];
          _results = [];
          for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
            e = _ref6[_k];
            _results.push(e.message);
          }
          return _results;
        })(), date) >= 0;
      }
    });
    tests.add({
      'prereq': true,
      'name': 'Tell the app to send a message',
      'previous': 'Connected to the corresponding chan',
      'delay': 300,
      'check': function() {
        return workers[testChan].emit('test', 'Send message');
      }
    });
    tests.add({
      'name': 'Send a message via the app',
      'previous': 'Tell the app to send a message',
      'delay': 1000,
      'check': function() {
        var e;

        return __indexOf.call((function() {
          var _k, _len2, _ref6, _results;

          _ref6 = storage.messagesHistory[testChan];
          _results = [];
          for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
            e = _ref6[_k];
            _results.push(e.message);
          }
          return _results;
        })(), 'coucou') >= 0;
      }
    });
    tests.add({
      'prereq': true,
      'name': 'Are messages in history really displayed ?',
      'previous': 'Receive a message and save it in history',
      'delay': 2000,
      'check': function() {
        return workers[testChan].emit('test', 'Are messages in history really displayed ?', storage.messagesHistory[testChan]);
      }
    });
    tests.add({
      'name': 'Display messages from updated history ',
      'previous': 'Are messages in history really displayed ?',
      'delay': 300,
      'check': function() {
        return testPortReplies['Are messages in history really displayed ? : true'];
      }
    });
    tests.add({
      'prereq': true,
      'name': 'Send a pm to the client via the testing bot',
      'previous': 'Connected to the corresponding chan',
      'delay': 2000,
      'check': function() {
        return client.say(testBot, 'pm ' + date);
      }
    });
    tests.add({
      'name': 'Save a pm in history when received',
      'previous': 'Send a pm to the client via the testing bot',
      'delay': 4000,
      'check': function() {
        var e, _base, _ref6;

        if ((_ref6 = (_base = storage.privateMessagesHistory)[testBot]) == null) {
          _base[testBot] = [];
        }
        return __indexOf.call((function() {
          var _k, _len2, _ref7, _results;

          _ref7 = storage.privateMessagesHistory[testBot];
          _results = [];
          for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
            e = _ref7[_k];
            _results.push(e.message);
          }
          return _results;
        })(), date) >= 0;
      }
    });
    tests.add({
      'prereq': true,
      'name': 'Updated pm users list ?',
      'previous': 'Save a pm in history when received',
      'delay': 300,
      'check': function() {
        return workers[testChan].emit('test', 'Updated pm users list ?', testBot);
      }
    });
    tests.add({
      'name': 'Start a new pm conversation when a pm is received',
      'previous': 'Updated pm users list ?',
      'delay': 1000,
      'check': function() {
        return testPortReplies['Updated pm users list ? : true'];
      }
    });
    tests.run();
  }

}).call(this);
