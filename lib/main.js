// Generated by CoffeeScript 1.6.2
(function() {
  var Channel, Tests, URL, activePrivateUsers, client, closePage, currentPmUser, data, date, emitToAllWorkers, getChan, irc, mutedUsers, openPage, panel, passEvent, pmUsers, resonanceOptions, setTimeout, sha1, startClient, storage, tabs, testBot, testChan, testPortReplies, tests, workers, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  data = require("sdk/self").data;

  URL = require('sdk/url').URL;

  tabs = require('sdk/tabs');

  data = require("sdk/self").data;

  storage = require("sdk/simple-storage").storage;

  sha1 = require('./sha1.js').sha1;

  irc = require('./_irc.js');

  resonanceOptions = {
    'activated': true,
    'startByDefault': true,
    'startForDomains': [],
    'nick': 'zob_du_test'
  };

  storage.messagesHistory = {};

  storage.privateMessagesHistory = {};

  activePrivateUsers = {};

  mutedUsers = (_ref = storage.mutedUsers) != null ? _ref : [];

  workers = {};

  pmUsers = ['Resonance-bot'];

  currentPmUser = 'Resonance-bot';

  client = {};

  startClient = function(opt) {
    client = new irc.Client('chat.freenode.net', opt.nick, {
      debug: true
    });
    client.addListener('error', function(message) {
      emitToAllWorkers('error', message.command + message.args.join(' '));
      return console.error('ERROR:', message.command, message.args.join(' '));
    });
    client.addListener('registered', function(message) {
      return client.connected = true;
    });
    passEvent('names');
    passEvent('join');
    client.addListener('message', function(from, to, message) {
      var _base, _ref1;

      if (to !== opt.nick) {
        workers[to].emit('message', from, to, message);
        if ((_ref1 = (_base = storage.messagesHistory)[to]) == null) {
          _base[to] = [];
        }
        return storage.messagesHistory[to].push({
          'author': from,
          'message': message
        });
      }
    });
    client.addListener('pm', function(from, message) {
      var _base, _ref1;

      if (from === 'Resonance-bot' && message.match(/^announce /)) {
        message = message.replace('announce ', '');
        return emitToAllWorkers('announce', message);
      } else if (from === 'Resonance-bot' && message.match(/^topPages /)) {
        message = message.replace('topPages ', '');
        return emitToAllWorkers('topPages', message);
      } else {
        if (!(__indexOf.call(pmUsers, from) >= 0)) {
          pmUsers.push(from);
          emitToAllWorkers('pmUsers', pmUsers);
        }
        if ((_ref1 = (_base = storage.privateMessagesHistory)[from]) == null) {
          _base[from] = [];
        }
        storage.privateMessagesHistory[from].push({
          'author': from,
          'message': message
        });
        activePrivateUsers[from] = true;
        emitToAllWorkers('activePrivateUsers', activePrivateUsers);
        if (from === currentPmUser) {
          return emitToAllWorkers('privateMessage', from, opt.nick, message);
        }
      }
    });
    client.addListener('part', function(chan, nick) {
      if (nick !== opt.nick) {
        return workers[chan].emit('part', chan, nick);
      }
    });
    return client;
  };

  getChan = function(url, title) {
    var c, domain, _ref1, _ref2;

    domain = (_ref1 = url.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)) != null ? (_ref2 = _ref1[2]) != null ? _ref2 : _ref1[2] = '' : void 0;
    c = '#' + sha1(domain + title).toString();
    return c;
  };

  passEvent = function(eventName) {
    return client.addListener(eventName, function(chan, a, b, c, d, e, f, g, h, i) {
      if (workers[chan] != null) {
        return workers[chan].emit(eventName, chan, a, b, c, d, e, f, g, h, i);
      }
    });
  };

  emitToAllWorkers = function(eventName, a, b, c, d, e, f, g, h, i) {
    var chan, worker, _results;

    _results = [];
    for (chan in workers) {
      if (!__hasProp.call(workers, chan)) continue;
      worker = workers[chan];
      _results.push(worker.emit(eventName, a, b, c, d, e, f, g, h, i));
    }
    return _results;
  };

  Channel = (function() {
    function Channel(chan, worker) {
      this.chan = chan;
      this.linkedWorkers = [worker];
    }

    Channel.prototype.addWorker = function(worker) {
      return this.linkedWorkers.push(worker);
    };

    Channel.prototype.removeWorker = function(worker) {
      var w;

      return this.linkedWorkers = (function() {
        var _i, _len, _ref1, _results;

        _ref1 = this.linkedWorkers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          w = _ref1[_i];
          if (w !== worker) {
            _results.push(w);
          }
        }
        return _results;
      }).call(this);
    };

    Channel.prototype.emit = function(eventName, a, b, c, d, e, f, g, h, i) {
      var w, _i, _len, _ref1, _results;

      _ref1 = this.linkedWorkers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        w = _ref1[_i];
        _results.push(w.port.emit(eventName, a, b, c, d, e, f, g, h, i));
      }
      return _results;
    };

    Channel.prototype.hasWorkers = function() {
      return this.linkedWorkers.length > 0;
    };

    Channel.prototype.numWorkers = function() {
      return this.linkedWorkers.length;
    };

    return Channel;

  })();

  closePage = function(tab) {
    var previousChan, previousWorker;

    previousChan = tab.chan;
    previousWorker = tab.worker;
    workers[previousChan].removeWorker(previousWorker);
    if (!workers[previousChan].hasWorkers()) {
      client.part(previousChan);
      return delete workers[previousChan];
    }
  };

  openPage = function(tab) {
    var chan, worker, _base, _ref1, _ref2, _ref3;

    chan = getChan(tab.url, tab.title);
    tab.chan = chan;
    client.join(chan);
    client.send('NAMES', chan);
    client.say('Resonance-bot', 'enter ' + tab.url + ' ' + chan);
    worker = tab.attach({
      contentScriptFile: [data.url("lib/jquery.js"), data.url("lib/angular.min.js"), data.url("content-built.js"), data.url("controllers/app.js"), data.url("controllers/ResonanceController.js"), data.url("controllers/IrcController.js"), data.url("controllers/MessagesController.js"), data.url("controllers/UsersController.js"), data.url("controllers/TopPagesController.js"), data.url("controllers/SettingsController.js"), data.url("controllers/PrivateMessagesController.js"), data.url("controllers/PrivateUsersController.js"), data.url("tests.js")]
    });
    tab.worker = worker;
    if (workers[chan] != null) {
      workers[chan].addWorker(worker);
    } else {
      workers[chan] = new Channel(chan, worker);
    }
    worker.port.emit('appSize', (_ref1 = storage.appSize) != null ? _ref1 : '100');
    worker.port.emit('chan', chan);
    worker.port.emit('requestMutedUsers', mutedUsers);
    worker.port.emit('nick', resonanceOptions.nick);
    worker.port.emit('messagesHistory', (_ref2 = storage.messagesHistory[chan]) != null ? _ref2 : []);
    worker.port.emit('pmUsers', pmUsers);
    if ((_ref3 = (_base = storage.privateMessagesHistory)[currentPmUser]) == null) {
      _base[currentPmUser] = [];
    }
    worker.port.emit('pmUser', currentPmUser, storage.privateMessagesHistory[currentPmUser]);
    worker.port.on('say', function(to, message) {
      var _base1, _ref4;

      client.say(to, message);
      workers[to].emit('message', resonanceOptions.nick, to, message);
      if ((_ref4 = (_base1 = storage.messagesHistory)[to]) == null) {
        _base1[to] = [];
      }
      return storage.messagesHistory[to].push({
        'author': resonanceOptions.nick,
        'message': message
      });
    });
    worker.port.on('privateMessage', function(user, message) {
      var _base1, _ref4;

      client.say(user, message);
      if ((_ref4 = (_base1 = storage.privateMessagesHistory)[user]) == null) {
        _base1[user] = [];
      }
      storage.privateMessagesHistory[user].push({
        'author': resonanceOptions.nick,
        'message': message
      });
      return emitToAllWorkers('privateMessage', resonanceOptions.nick, user, message);
    });
    worker.port.on('getTopPages', function(domain) {
      if (domain !== null && domain !== '') {
        return client.say('Resonance-bot', 'ask keyword ' + domain);
      } else {
        return client.say('Resonance-bot', 'ask global');
      }
    });
    worker.port.on('startPmUser', function(user) {
      var _base1, _ref4;

      currentPmUser = user;
      if (!(__indexOf.call(pmUsers, user) >= 0)) {
        pmUsers.push(user);
        emitToAllWorkers('pmUsers', pmUsers);
      }
      if ((_ref4 = (_base1 = storage.privateMessagesHistory)[user]) == null) {
        _base1[user] = [];
      }
      return emitToAllWorkers('pmUser', currentPmUser, storage.privateMessagesHistory[user]);
    });
    worker.port.on("newNick", function(nick) {
      resonanceOptions.nick = nick;
      return worker.port.emit('message', 'Resonance', resonanceOptions.nick, 'Your new nick will be saved and available as soon as you restart firefox.');
    });
    worker.port.on("updateMutedUsers", function(mutedUsers) {
      return storage.mutedUsers = mutedUsers;
    });
    worker.port.on('unactivePmUser', function(user) {
      activePrivateUsers[user] = false;
      return emitToAllWorkers('activePrivateUsers', activePrivateUsers);
    });
    worker.port.on("newAppSize", function(height) {
      storage.appSize = height;
      return emitToAllWorkers('appSize', height);
    });
    return worker.port.on('test', function(response) {
      return testPortReplies[response] = true;
    });
  };

  panel = require("sdk/panel").Panel({
    'width': 800,
    'height': 200,
    'contentURL': data.url("panel.html"),
    'contentScriptFile': [data.url("lib/angular.min.js"), data.url("lib/jquery.js"), data.url("panel_controllers/panel.js")]
  });

  require("sdk/widget").Widget({
    'id': "widget-open-settings",
    'label': "Resonance",
    'contentURL': data.url("History.png"),
    'panel': panel,
    'onClick': function() {
      var _ref1, _ref2;

      resonanceOptions['domain'] = (_ref1 = tabs.activeTab.url.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)) != null ? (_ref2 = _ref1[2]) != null ? _ref2 : _ref1[2] = '' : void 0;
      resonanceOptions['started'] = false;
      return panel.port.emit('initOptions', resonanceOptions);
    }
  });

  panel.port.on('updateOptions', function(opt) {
    return resonanceOptions = opt;
  });

  panel.port.on('activate', function(value) {
    if (value) {
      return startClient(resonanceOptions);
    } else {
      return client.disconnect();
    }
  });

  panel.port.on('startForPage', function(value) {
    if (value) {

    } else {

    }
  });

  if (resonanceOptions.activated) {
    startClient(resonanceOptions);
  }

  tabs.on('ready', function(tab) {
    var domain, _ref1, _ref2;

    if (resonanceOptions.activated) {
      domain = (_ref1 = tab.url.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/)) != null ? (_ref2 = _ref1[2]) != null ? _ref2 : _ref1[2] = '' : void 0;
      if (resonanceOptions.startByDefault || (__indexOf.call(resonanceOptions.startForDomains, domain) >= 0)) {
        if (tab.chan != null) {
          closePage(tab);
        }
        return openPage(tab);
      }
    }
  });

  tabs.on('close', function(tab) {
    workers[tab.chan].removeWorker(tab.worker);
    if (!workers[tab.chan].hasWorkers()) {
      client.part(tab.chan);
      return delete workers[tab.chan];
    }
  });

  setTimeout = require('sdk/timers').setTimeout;

  Tests = (function() {
    function Tests() {
      this.assert = __bind(this.assert, this);      this.tests = [];
      this.rootTests = [];
    }

    Tests.prototype.add = function(test) {
      var prevTest, t, _ref1;

      test.followers = [];
      this.tests.push(test);
      if (!(_ref1 = test.previous, __indexOf.call((function() {
        var _i, _len, _ref2, _results;

        _ref2 = this.tests;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          t = _ref2[_i];
          _results.push(t.name);
        }
        return _results;
      }).call(this), _ref1) >= 0)) {
        return this.rootTests.push(test);
      } else {
        prevTest = ((function() {
          var _i, _len, _ref2, _results;

          _ref2 = this.tests;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            t = _ref2[_i];
            if (t.name === test.previous) {
              _results.push(t);
            }
          }
          return _results;
        }).call(this))[0];
        return this.follow(test, prevTest);
      }
    };

    Tests.prototype.follow = function(follower, firstTest) {
      return firstTest.followers.push(follower);
    };

    Tests.prototype.run = function() {
      var test, _i, _len, _ref1, _results;

      _ref1 = this.rootTests;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        test = _ref1[_i];
        _results.push(this.assert(test));
      }
      return _results;
    };

    Tests.prototype.assert = function(test) {
      var assert, next, result, _i, _len, _ref1, _results;

      result = '\n\t\tFAILED.\n';
      if (test.check()) {
        result = 'Passed.';
      }
      if (!(test.prereq != null)) {
        console.log('[[ TESTS ]] ' + test.name + ' : ' + result);
      }
      assert = this.assert;
      _ref1 = test.followers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        next = _ref1[_i];
        _results.push((function(next) {
          return setTimeout((function() {
            return assert(next);
          }), next.delay);
        })(next));
      }
      return _results;
    };

    return Tests;

  })();

  tests = new Tests();

  tests.add({
    'name': 'Addon started',
    'previous': '',
    'delay': 0,
    'check': function() {
      return true;
    }
  });

  tests.add({
    'name': 'Storage available',
    'previous': '',
    'delay': 0,
    'check': function() {
      return storage != null;
    }
  });

  tests.add({
    'name': 'Client connected in less than 20s',
    'previous': 'Addon started',
    'delay': 20000,
    'check': function() {
      return client.connected;
    }
  });

  testPortReplies = {};

  tests.add({
    'prereq': true,
    'name': 'Open sebsauvage.net',
    'previous': 'Addon started',
    'delay': 1000,
    'check': function() {
      return tabs.open('sebsauvage.net');
    }
  });

  tests.add({
    'prereq': true,
    'name': 'sebsauvage.net is open',
    'previous': 'Open sebsauvage.net',
    'delay': 10000,
    'check': function() {
      return tabs.activeTab.url === 'http://sebsauvage.net/';
    }
  });

  testChan = '';

  tests.add({
    'name': 'tab.chan is correctly defined for sebsauvage',
    'previous': 'sebsauvage.net is open',
    'delay': 100,
    'check': function() {
      testChan = getChan(tabs.activeTab.url, tabs.activeTab.title);
      return tabs.activeTab.chan === testChan;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Test port communication with the tab of sebsauvage',
    'previous': 'sebsauvage.net is open',
    'delay': 100,
    'check': function() {
      return workers[testChan].emit('test', 'Test port communication');
    }
  });

  tests.add({
    'name': 'workers[chan] allow communication with the correct tab for sebsauvage ',
    'previous': 'Test port communication with the tab of sebsauvage',
    'delay': 300,
    'check': function() {
      return testPortReplies['Test port communication : sebsauvage.net'];
    }
  });

  tests.add({
    'prereq': true,
    'name': 'App displayed, ~full ?',
    'previous': 'sebsauvage.net is open',
    'delay': 2000,
    'check': function() {
      return workers[testChan].emit('test', 'App displayed, ~full ?');
    }
  });

  tests.add({
    'name': 'The app is displayed (>90% width)',
    'previous': 'App displayed, ~full ?',
    'delay': 1000,
    'check': function() {
      return testPortReplies['App displayed, ~full ? : true'];
    }
  });

  testBot = 'Resonance-test';

  storage.messagesHistory = {};

  storage.privateMessagesHistory = {};

  tests.add({
    'name': 'Connected to the corresponding chan',
    'previous': 'Client connected in less than 20s',
    'delay': 4000,
    'check': function() {
      var chan;

      client.say(testBot, 'join ' + testChan);
      for (chan in client.chans) {
        if (chan === testChan) {
          return true;
        }
      }
      return false;
    }
  });

  date = new Date();

  date = date.toString();

  tests.add({
    'prereq': true,
    'name': 'Send a message in the chan via the testing bot',
    'previous': 'Connected to the corresponding chan',
    'delay': 2000,
    'check': function() {
      return client.say(testBot, 'say ' + testChan + ' ' + date);
    }
  });

  tests.add({
    'name': 'Receive a message and save it in history',
    'previous': 'Send a message in the chan via the testing bot',
    'delay': 4000,
    'check': function() {
      var e;

      return __indexOf.call((function() {
        var _i, _len, _ref1, _results;

        _ref1 = storage.messagesHistory[testChan];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          e = _ref1[_i];
          _results.push(e.message);
        }
        return _results;
      })(), date) >= 0;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Tell the app to send a message',
    'previous': 'Connected to the corresponding chan',
    'delay': 300,
    'check': function() {
      return workers[testChan].emit('test', 'Send message');
    }
  });

  tests.add({
    'name': 'Send a message via the app',
    'previous': 'Tell the app to send a message',
    'delay': 1000,
    'check': function() {
      var e;

      return __indexOf.call((function() {
        var _i, _len, _ref1, _results;

        _ref1 = storage.messagesHistory[testChan];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          e = _ref1[_i];
          _results.push(e.message);
        }
        return _results;
      })(), 'coucou') >= 0;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Are messages in history really displayed ?',
    'previous': 'Receive a message and save it in history',
    'delay': 2000,
    'check': function() {
      console.log(storage.messagesHistory[testChan]);
      return workers[testChan].emit('test', 'Are messages in history really displayed ?', storage.messagesHistory[testChan]);
    }
  });

  tests.add({
    'name': 'Display messages from updated history ',
    'previous': 'Are messages in history really displayed ?',
    'delay': 300,
    'check': function() {
      return testPortReplies['Are messages in history really displayed ? : true'];
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Send a pm to the client via the testing bot',
    'previous': 'Connected to the corresponding chan',
    'delay': 2000,
    'check': function() {
      return client.say(testBot, 'pm ' + date);
    }
  });

  tests.add({
    'name': 'Save a pm in history when received',
    'previous': 'Send a pm to the client via the testing bot',
    'delay': 4000,
    'check': function() {
      var e, _base, _ref1;

      if ((_ref1 = (_base = storage.privateMessagesHistory)[testBot]) == null) {
        _base[testBot] = [];
      }
      return __indexOf.call((function() {
        var _i, _len, _ref2, _results;

        _ref2 = storage.privateMessagesHistory[testBot];
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          e = _ref2[_i];
          _results.push(e.message);
        }
        return _results;
      })(), date) >= 0;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Updated pm users list ?',
    'previous': 'Save a pm in history when received',
    'delay': 300,
    'check': function() {
      return workers[testChan].emit('test', 'Updated pm users list ?', testBot);
    }
  });

  tests.add({
    'name': 'Start a new pm conversation when a pm is received',
    'previous': 'Updated pm users list ?',
    'delay': 1000,
    'check': function() {
      return testPortReplies['Updated pm users list ? : true'];
    }
  });

  tests.run();

}).call(this);
