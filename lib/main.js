// Generated by CoffeeScript 1.6.2
(function() {
  var Channel, Tests, URL, activePrivateUsers, chan, client, currentNick, currentPmUser, data, date, emitToAllWorkers, irc, list, m, mutedUsers, passEvent, pmUsers, setTimeout, sha1, storage, tabs, testBot, testChan, testPortReplies, tests, user, widgets, workers, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  widgets = require("sdk/widget");

  URL = require('sdk/url').URL;

  tabs = require('sdk/tabs');

  data = require("sdk/self").data;

  storage = require("sdk/simple-storage").storage;

  sha1 = require('./sha1.js').sha1;

  irc = require('./_irc.js');

  storage.messagesHistory = {};

  storage.privateMessagesHistory = {};

  _ref = storage.messagesHistory;
  for (chan in _ref) {
    list = _ref[chan];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      m = list[_i];
      m.old = 'true';
    }
  }

  _ref1 = storage.privateMessagesHistory;
  for (user in _ref1) {
    list = _ref1[user];
    for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
      m = list[_j];
      m.old = 'true';
    }
  }

  pmUsers = ['Resonance-bot'];

  currentPmUser = 'Resonance-bot';

  activePrivateUsers = {};

  mutedUsers = (_ref2 = storage.mutedUsers) != null ? _ref2 : [];

  storage.nick = 'Mazdra_ta_mere';

  currentNick = (_ref3 = storage.nick) != null ? _ref3 : 'Resonance-dev';

  client = new irc.Client('chat.freenode.net', currentNick, {
    debug: true
  });

  client.addListener('error', function(message) {
    emitToAllWorkers('error', message.command + message.args.join(' '));
    return console.error('ERROR:', message.command, message.args.join(' '));
  });

  client.addListener('registered', function(message) {
    return client.connected = true;
  });

  client.addListener('message', function(from, to, message) {
    var _base, _ref4;

    if (to !== currentNick) {
      workers[to].emit('message', from, to, message);
      if ((_ref4 = (_base = storage.messagesHistory)[to]) == null) {
        _base[to] = [];
      }
      return storage.messagesHistory[to].push({
        'author': from,
        'message': message
      });
    }
  });

  client.addListener('pm', function(from, message) {
    var _base, _ref4;

    if (from === 'Resonance-bot' && message.match(/^announce /)) {
      message = message.replace('announce ', '');
      return emitToAllWorkers('announce', message);
    } else if (from === 'Resonance-bot' && message.match(/^topPages /)) {
      message = message.replace('topPages ', '');
      return emitToAllWorkers('topPages', message);
    } else {
      if (!(__indexOf.call(pmUsers, from) >= 0)) {
        pmUsers.push(from);
        emitToAllWorkers('pmUsers', pmUsers);
      }
      if ((_ref4 = (_base = storage.privateMessagesHistory)[from]) == null) {
        _base[from] = [];
      }
      storage.privateMessagesHistory[from].push({
        'author': from,
        'message': message
      });
      activePrivateUsers[from] = true;
      emitToAllWorkers('activePrivateUsers', activePrivateUsers);
      if (from === currentPmUser) {
        return emitToAllWorkers('privateMessage', from, currentNick, message);
      }
    }
  });

  client.addListener('part', function(chan, nick) {
    if (nick !== currentNick) {
      return workers[chan].emit('part', chan, nick);
    }
  });

  passEvent = function(eventName) {
    return client.addListener(eventName, function(chan, a, b, c, d, e, f, g, h, i) {
      if (workers[chan] != null) {
        return workers[chan].emit(eventName, chan, a, b, c, d, e, f, g, h, i);
      }
    });
  };

  passEvent('names');

  passEvent('join');

  emitToAllWorkers = function(eventName, a, b, c, d, e, f, g, h, i) {
    var worker, _results;

    _results = [];
    for (chan in workers) {
      if (!__hasProp.call(workers, chan)) continue;
      worker = workers[chan];
      _results.push(worker.emit(eventName, a, b, c, d, e, f, g, h, i));
    }
    return _results;
  };

  workers = {};

  Channel = (function() {
    function Channel(chan, worker) {
      this.chan = chan;
      this.linkedWorkers = [worker];
    }

    Channel.prototype.addWorker = function(worker) {
      return this.linkedWorkers.push(worker);
    };

    Channel.prototype.removeWorker = function(worker) {
      var w;

      return this.linkedWorkers = (function() {
        var _k, _len2, _ref4, _results;

        _ref4 = this.linkedWorkers;
        _results = [];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          w = _ref4[_k];
          if (w !== worker) {
            _results.push(w);
          }
        }
        return _results;
      }).call(this);
    };

    Channel.prototype.emit = function(eventName, a, b, c, d, e, f, g, h, i) {
      var w, _k, _len2, _ref4, _results;

      _ref4 = this.linkedWorkers;
      _results = [];
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        w = _ref4[_k];
        _results.push(w.port.emit(eventName, a, b, c, d, e, f, g, h, i));
      }
      return _results;
    };

    Channel.prototype.hasWorkers = function() {
      return this.linkedWorkers.length > 0;
    };

    Channel.prototype.numWorkers = function() {
      return this.linkedWorkers.length;
    };

    return Channel;

  })();

  tabs.on('ready', function(tab) {
    var previousChan, previousWorker, worker, _base, _ref4, _ref5, _ref6;

    if (tab.chan != null) {
      previousChan = tab.chan;
      previousWorker = tab.worker;
      workers[previousChan].removeWorker(previousWorker);
      if (!workers[previousChan].hasWorkers()) {
        client.part(previousChan);
        delete workers[previousChan];
      }
    }
    chan = '#' + sha1(tab.url + tab.title).toString();
    tab.chan = chan;
    client.join(chan);
    client.send('NAMES', chan);
    client.say('Resonance-bot', 'enter ' + tab.url + ' ' + chan);
    worker = tab.attach({
      contentScriptFile: [data.url("lib/jquery.js"), data.url("lib/angular.min.js"), data.url("content-built.js"), data.url("controllers/app.js"), data.url("controllers/ResonanceController.js"), data.url("controllers/IrcController.js"), data.url("controllers/MessagesController.js"), data.url("controllers/UsersController.js"), data.url("controllers/TopPagesController.js"), data.url("controllers/SettingsController.js"), data.url("controllers/PrivateMessagesController.js"), data.url("controllers/PrivateUsersController.js"), data.url("tests.js")]
    });
    tab.worker = worker;
    if (workers[chan] != null) {
      workers[chan].addWorker(worker);
    } else {
      workers[chan] = new Channel(chan, worker);
    }
    worker.port.emit('appSize', (_ref4 = storage.appSize) != null ? _ref4 : '100');
    worker.port.emit('chan', chan);
    worker.port.emit('requestMutedUsers', mutedUsers);
    worker.port.emit('nick', currentNick);
    worker.port.emit('messagesHistory', (_ref5 = storage.messagesHistory[chan]) != null ? _ref5 : []);
    worker.port.emit('pmUsers', pmUsers);
    if ((_ref6 = (_base = storage.privateMessagesHistory)[currentPmUser]) == null) {
      _base[currentPmUser] = [];
    }
    worker.port.emit('pmUser', currentPmUser, storage.privateMessagesHistory[currentPmUser]);
    worker.port.on('say', function(to, message) {
      var _base1, _ref7;

      client.say(to, message);
      workers[to].emit('message', currentNick, to, message);
      if ((_ref7 = (_base1 = storage.messagesHistory)[to]) == null) {
        _base1[to] = [];
      }
      return storage.messagesHistory[to].push({
        'author': currentNick,
        'message': message
      });
    });
    worker.port.on('privateMessage', function(user, message) {
      var _base1, _ref7;

      client.say(user, message);
      if ((_ref7 = (_base1 = storage.privateMessagesHistory)[user]) == null) {
        _base1[user] = [];
      }
      storage.privateMessagesHistory[user].push({
        'author': currentNick,
        'message': message
      });
      return emitToAllWorkers('privateMessage', currentNick, user, message);
    });
    worker.port.on('getTopPages', function() {
      return client.say('Resonance-bot', 'ask');
    });
    worker.port.on('startPmUser', function(user) {
      var _base1, _ref7;

      currentPmUser = user;
      if (!(__indexOf.call(pmUsers, user) >= 0)) {
        pmUsers.push(user);
        emitToAllWorkers('pmUsers', pmUsers);
      }
      if ((_ref7 = (_base1 = storage.privateMessagesHistory)[user]) == null) {
        _base1[user] = [];
      }
      return emitToAllWorkers('pmUser', currentPmUser, storage.privateMessagesHistory[user]);
    });
    worker.port.on("newNick", function(nick) {
      storage.nick = nick;
      currentNick = nick;
      return worker.port.emit('message', 'Resonance', currentNick, 'Your new nick will be saved and available as soon as you restart firefox.');
    });
    worker.port.on("updateMutedUsers", function(mutedUsers) {
      return storage.mutedUsers = mutedUsers;
    });
    worker.port.on('unactivePmUser', function(user) {
      activePrivateUsers[user] = false;
      return emitToAllWorkers('activePrivateUsers', activePrivateUsers);
    });
    worker.port.on("newAppSize", function(height) {
      storage.appSize = height;
      return emitToAllWorkers('appSize', height);
    });
    return worker.port.on('test', function(response) {
      return testPortReplies[response] = true;
    });
  });

  tabs.on('close', function(tab) {
    workers[tab.chan].removeWorker(tab.worker);
    if (!workers[tab.chan].hasWorkers()) {
      client.part(tab.chan);
      return delete workers[tab.chan];
    }
  });

  setTimeout = require('sdk/timers').setTimeout;

  Tests = (function() {
    function Tests() {
      this.assert = __bind(this.assert, this);      this.tests = [];
      this.rootTests = [];
    }

    Tests.prototype.add = function(test) {
      var prevTest, t, _ref4;

      test.followers = [];
      this.tests.push(test);
      if (!(_ref4 = test.previous, __indexOf.call((function() {
        var _k, _len2, _ref5, _results;

        _ref5 = this.tests;
        _results = [];
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          t = _ref5[_k];
          _results.push(t.name);
        }
        return _results;
      }).call(this), _ref4) >= 0)) {
        return this.rootTests.push(test);
      } else {
        prevTest = ((function() {
          var _k, _len2, _ref5, _results;

          _ref5 = this.tests;
          _results = [];
          for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
            t = _ref5[_k];
            if (t.name === test.previous) {
              _results.push(t);
            }
          }
          return _results;
        }).call(this))[0];
        return this.follow(test, prevTest);
      }
    };

    Tests.prototype.follow = function(follower, firstTest) {
      return firstTest.followers.push(follower);
    };

    Tests.prototype.run = function() {
      var test, _k, _len2, _ref4, _results;

      _ref4 = this.rootTests;
      _results = [];
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        test = _ref4[_k];
        _results.push(this.assert(test));
      }
      return _results;
    };

    Tests.prototype.assert = function(test) {
      var assert, next, result, _k, _len2, _ref4, _results;

      result = '\n\t\tFAILED.\n';
      if (test.check()) {
        result = 'Passed.';
      }
      if (!(test.prereq != null)) {
        console.log('[[ TESTS ]] ' + test.name + ' : ' + result);
      }
      assert = this.assert;
      _ref4 = test.followers;
      _results = [];
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        next = _ref4[_k];
        _results.push((function(next) {
          return setTimeout((function() {
            return assert(next);
          }), next.delay);
        })(next));
      }
      return _results;
    };

    return Tests;

  })();

  tests = new Tests();

  tests.add({
    'name': 'Addon started',
    'previous': '',
    'delay': 0,
    'check': function() {
      return true;
    }
  });

  tests.add({
    'name': 'Storage available',
    'previous': '',
    'delay': 0,
    'check': function() {
      return storage != null;
    }
  });

  tests.add({
    'name': 'Client connected in less than 20s',
    'previous': 'Addon started',
    'delay': 20000,
    'check': function() {
      return client.connected;
    }
  });

  testPortReplies = {};

  tests.add({
    'prereq': true,
    'name': 'Open sebsauvage.net',
    'previous': 'Addon started',
    'delay': 1000,
    'check': function() {
      return tabs.open('sebsauvage.net');
    }
  });

  tests.add({
    'prereq': true,
    'name': 'sebsauvage.net is open',
    'previous': 'Open sebsauvage.net',
    'delay': 10000,
    'check': function() {
      return tabs.activeTab.url === 'http://sebsauvage.net/';
    }
  });

  testChan = '';

  tests.add({
    'name': 'tab.chan is correctly defined for sebsauvage',
    'previous': 'sebsauvage.net is open',
    'delay': 100,
    'check': function() {
      testChan = '#' + sha1(tabs.activeTab.url + tabs.activeTab.title).toString();
      return tabs.activeTab.chan === testChan;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Test port communication with the tab of sebsauvage',
    'previous': 'sebsauvage.net is open',
    'delay': 100,
    'check': function() {
      return workers[testChan].emit('test', 'Test port communication');
    }
  });

  tests.add({
    'name': 'workers[chan] allow communication with the correct tab for sebsauvage ',
    'previous': 'Test port communication with the tab of sebsauvage',
    'delay': 300,
    'check': function() {
      return testPortReplies['Test port communication : sebsauvage.net'];
    }
  });

  tests.add({
    'prereq': true,
    'name': 'App displayed, ~full ?',
    'previous': 'sebsauvage.net is open',
    'delay': 2000,
    'check': function() {
      return workers[testChan].emit('test', 'App displayed, ~full ?');
    }
  });

  tests.add({
    'name': 'The app is displayed (>90% width)',
    'previous': 'App displayed, ~full ?',
    'delay': 1000,
    'check': function() {
      return testPortReplies['App displayed, ~full ? : true'];
    }
  });

  testBot = 'Resonance-test';

  storage.messagesHistory = {};

  storage.privateMessagesHistory = {};

  tests.add({
    'name': 'Connected to the corresponding chan',
    'previous': 'Client connected in less than 20s',
    'delay': 4000,
    'check': function() {
      testChan = '#' + sha1(tabs.activeTab.url + tabs.activeTab.title).toString();
      client.say(testBot, 'join ' + testChan);
      for (chan in client.chans) {
        if (chan === testChan) {
          return true;
        }
      }
      return false;
    }
  });

  date = new Date();

  date = date.toString();

  tests.add({
    'prereq': true,
    'name': 'Send a message in the chan via the testing bot',
    'previous': 'Connected to the corresponding chan',
    'delay': 2000,
    'check': function() {
      return client.say(testBot, 'say ' + testChan + ' ' + date);
    }
  });

  tests.add({
    'name': 'Receive a message and save it in history',
    'previous': 'Send a message in the chan via the testing bot',
    'delay': 4000,
    'check': function() {
      var e;

      return __indexOf.call((function() {
        var _k, _len2, _ref4, _results;

        _ref4 = storage.messagesHistory[testChan];
        _results = [];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          e = _ref4[_k];
          _results.push(e.message);
        }
        return _results;
      })(), date) >= 0;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Tell the app to send a message',
    'previous': 'Connected to the corresponding chan',
    'delay': 300,
    'check': function() {
      return workers[testChan].emit('test', 'Send message');
    }
  });

  tests.add({
    'name': 'Send a message via the app',
    'previous': 'Tell the app to send a message',
    'delay': 1000,
    'check': function() {
      var e;

      return __indexOf.call((function() {
        var _k, _len2, _ref4, _results;

        _ref4 = storage.messagesHistory[testChan];
        _results = [];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          e = _ref4[_k];
          _results.push(e.message);
        }
        return _results;
      })(), 'coucou') >= 0;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Are messages in history really displayed ?',
    'previous': 'Receive a message and save it in history',
    'delay': 2000,
    'check': function() {
      return workers[testChan].emit('test', 'Are messages in history really displayed ?', storage.messagesHistory[testChan]);
    }
  });

  tests.add({
    'name': 'Display messages from updated history ',
    'previous': 'Are messages in history really displayed ?',
    'delay': 300,
    'check': function() {
      return testPortReplies['Are messages in history really displayed ? : true'];
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Send a pm to the client via the testing bot',
    'previous': 'Connected to the corresponding chan',
    'delay': 2000,
    'check': function() {
      return client.say(testBot, 'pm ' + date);
    }
  });

  tests.add({
    'name': 'Save a pm in history when received',
    'previous': 'Send a pm to the client via the testing bot',
    'delay': 4000,
    'check': function() {
      var e, _base, _ref4;

      if ((_ref4 = (_base = storage.privateMessagesHistory)[testBot]) == null) {
        _base[testBot] = [];
      }
      return __indexOf.call((function() {
        var _k, _len2, _ref5, _results;

        _ref5 = storage.privateMessagesHistory[testBot];
        _results = [];
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          e = _ref5[_k];
          _results.push(e.message);
        }
        return _results;
      })(), date) >= 0;
    }
  });

  tests.add({
    'prereq': true,
    'name': 'Updated pm users list ?',
    'previous': 'Save a pm in history when received',
    'delay': 300,
    'check': function() {
      return workers[testChan].emit('test', 'Updated pm users list ?', testBot);
    }
  });

  tests.add({
    'name': 'Start a new pm conversation when a pm is received',
    'previous': 'Updated pm users list ?',
    'delay': 1000,
    'check': function() {
      return testPortReplies['Updated pm users list ? : true'];
    }
  });

  tests.run();

}).call(this);
